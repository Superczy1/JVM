## 十六、垃圾回收

![image-20210317194847495](.\picture\image-20210317194847495.png)

#### 1、什么是垃圾

* 运行程序中没有任何指针指向的对象
* 若不回收垃圾，则可能导致OOM

垃圾回收发生在方法区，和堆。堆是主要的GC。

* 频繁收集新生代
* 较少的养老代
* 极少的收集方法区

#### 2、标记阶段：引用计数法

对象是否存活：一个对象不被存活的对象引用就是死亡。

**引用计数**

* 每个对象保存一个整型的引用计数器：引用加一，引用失效减一。
* **优点**：实现简单，判断效率高，容易辨识，回收没有延迟。
* **缺点**：
  1. 增加了存储空间的开销
  2. 加减法增加了时间消耗
  3. **无法处理循环引用问题，所以java不使用该种方法，python使用**

![image-20210317202349812](.\picture\image-20210317202349812.png)

 **python是怎么解决的？**

* 手动解除引用
* 使用弱引用weakref，python提供的标准库，解决循环引用

#### 3、标记阶段：可达性算法

* 实现简单，执行高效
* 解决循环引用，防止内存泄漏
* Java，C#

**实现方式：使用 GC Roots**

1. 以 GC root 为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达。
2. 搜索过的路径称之为引用链
3. 若目标对象没有任何的引用链相连，则不可达，标记为垃圾回收对象
4. 只有被跟对象集合直接或者间接引用的对象是存活对象。
5. **必须在可以保存一致性的快照中进行。**这就导致了 咋瓦鲁多的需要（STW Stop the World）

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：GC root 包含那些元素？**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答:  1、JVM 栈中引用的对象； 2、本地方法栈；3、方法区中的静态对象；4、方法区中常量引用的对象；5、所有被同步锁持有的对象；6、 JVM内部的引用：系统类加载器 。除了固定的之外，根据垃圾回收器，可以将对象临时性加入（比如分代收集，局部回收）</span> 

#### 4、对象的 finalization

* 在垃圾回收对象之前，会先调用 finalize() 方法

* finalize() 方法允许在子类中被重写，用于在对象回收时进行资源释放。

* 不建议主动调用 finalize() 。 可能会导致对象复活。 该方法可能印象GC性能。

* 一般用来资源释放或者清理工作，关闭文件，套接字和数据库链接。

* 由于finalize() 存在对象会存在三种状态：若不可达，进入**缓刑**

  1. 可触及的：可达
  2. 可复活的：对象可能在 fianlize（）复活
  3. 不可触及：调用 finalize() 且没有复活，则进入不可触及的状态，因为该方法只调用一次。

  **判断对象是否可回收具体过程：**

  1. obj 没有引用链，进行第一次标记
  2. 进行筛选，判断是否有必要执行 finalize(）。
     1. 若 obj 没有重写 finalize()，或者 finalize() 被调过了。判定为不可触及。
     2. 若 obj 重写了 finalize() , 且未执行。那么 obj 会插入到 F-Queue 的队列中，有一个虚拟机创建的低优先级的 Finalizer 线程触发运行 finalize()。
     3. finalize() 是对象复活的最后机会。若在调用过程中 finalize() 与 任何一个引用链建立了联系，则复活。

#### 5、MAT  Jprofiler的GC root 溯源

获取dump

1.  jmap
2.  JvisualVM生成dump ，使用 MAT 打开
3.  Jprofiler

#### 6、清除阶段：标记清除（Mark Sweep）

步骤：当内存被耗尽，STW 

1. 标记：从GC Root 遍历，标记**所有被引用的对象**，在对象头中记录。
2. 清除：对堆内存从头到尾进行线性遍历，发现对象头为不可达，回收。
3. 缺点：效率不高（两次全遍历），进行GC 需要 STW ，用户体验差；清理出的空间不连续，产生空间碎片，需要维护**空闲列表**。

**何为清除？**

清除并不是真的置空，而是把清除的对象的地址保存在空闲列表里，下次新的对象加载时，判断空间是否足够，够就存放。

![image-20210317224448236](.\picture\image-20210317224448236.png)

#### 7、清除阶段：复制算法（Copying）

解决标记清除的效率的缺陷，核心思想：

1. 将活着的内存分为两块，使用其中的一块。
2. 在垃圾回收时将被使用内存上的活着的对象复制到另一块内存，再清除
3. 交换两个内存角色，完成垃圾回收。
4. 优点：
   * 效率很高，因为没有标记清除过程
   * 复制过去保证了空间的连续性
5. 缺点：
   * 需要牺牲空间
   * 对于 G1 这种分拆成很多区域的GC,复制而不是移动，GC需要维护不同区域之间的引用关系，时间开销也不小。
   * 当内存中垃圾对象过少的话，复制算法效率低。
   * 用于新生代

![image-20210317231805372](.\picture\image-20210317231805372.png)

#### 8、清除阶段：标记-压缩算法（Mark compat）

执行过程：

1. 第一阶段：标记，从根节点出发标记所有被引用的对象。
2. 第二阶段：将所有存活的对象压入内存的另外一端，按顺序排放
3. 与标记清除的区别在于，标记压缩需要移动。
4. 优点：没有复制算法空间减半的代价
5. 缺点：效率低于复制算法；移动对象时对象被其他对象引用还需要调整地址；移动过程中需要 STW

![image-20210318085617527](.\picture\image-20210318085617527.png)

![image-20210318090802730](.\picture\image-20210318090802730.png)

#### 9、分代收集

根据对象的存活周期的不同将内存划分几块。新生代使用复制算法，老年代使用标记-清除 或者 标记-压缩。

* 年轻代：区域相对于老年代小，对象存活时间小，回收频繁。使用复制算法
* 老年代：区域较大，对象生命周期长，存活率高，回收不频繁。
* 标记-清除，标记-压缩
* Mark阶段：开销与对象存活数量成正比
* Sweep阶段：与区域大小成正比
* Compact阶段：与存活对象数量成正比

#### 10、增量收集与分区算法

**增量收集------解决 GC 是系统停顿时间过长：** 在进行回收时造成系统长时间停顿，可以让回收与应用进程交替运行。 每次 GC 只收集一小部分，接着切换至应用线程。反复执行，直至垃圾回收完成。

缺点：不停的切换线程，能减少系统停顿时间，但是切换了消耗，造成系统吞吐量下降。

**分区算法**：将大的区域分成很多小块，为了减少 STW 的停顿时间。每个小区间独立回收。

![image-20210318092653605](.\picture\image-20210318092653605.png)

## 十七、垃圾回收的概念

#### 1、System.gc()

* 调用  System.gc() 会显式的出发 Full GC(新生代，老年代，方法区的GC),尝试释放废弃对象的内存。
* System.gc() 无法保证 GC 调用。
* System.runFinalization(); 强制调用失去引用的对象的 fianlize() 方法。

#### 2、内存溢出与内存泄漏

应用程序占用内存占用增长速度高于，内存回收速度，则易产生 OOM

**内存溢出（OOM）**：没有空闲的内存，并且垃圾回收也无法提供更多的内存。

原因：

1. Java虚拟机内存设置不够
2. 创建了大量的大对象，并且长时间GC不会回收这些对象。
   * 一般在报 OOM 之前会执行 GC，但是一旦分配一个大对象的，直接超过了内存总和，则直接 OOM

**内存泄漏（memory leak）**

严格来说：对象不再使用了，且GC不能回收他们，就叫内存泄漏。  

宽泛意义：程序中存在一些对象生命周期很长，导致 OOM。

内存泄漏可能导致 OOM

![image-20210318101324973](.\picture\image-20210318101324973.png)

举例：

* 单例模式：使用单例对象关联了外部的对象，因为单例对象的生命周期较长，所有外部对象即使不使用了也不会被回收，产生了内存泄漏。
* 一些提供close方法，但是忘记调用了

#### 3、STW（咋瓦撸多）

在进行 GC 是会停顿整个应用进程。 整个线程都会停顿，没有任何响应。

* 在进行可达性分析是，枚举根节点时，必须确保一致性（整个分析期间，所有线程停顿）
* 因为 STW 中断会终端用户，所以要减少 STW
* 所有GC 都有 STW
* STW 在 JVM 后台自动发起，自动完成。
* 显示调用 System.gc() 会触发 STW

#### 4、垃圾回收的并行并发

GC并行：多条垃圾回收线程并行工作，用户线程处于等待状态

串行：依次执行。

并发：同一个时间段，用户线程和垃圾回收共同进行。

#### 5、安全点

在 Hotspot 中用 OopMap 数据结构在进行类加载的过程中存放那些地方存放对象引用的。

在 OopMap 的帮助下，可以 Hotspot 可以快速的完成 GC Root的枚举。

**只有在抵达安全点的时候才能进行GC。安全点的选择：**

* 不能太少， GC等待时间长，太多导致性能问题。
* 选择标准：**是否具有让程序长时间执行的特征**-----每条指令都很短暂，程序不太可能因为指令流过长而长时间运行，“长时间运行“指的是指令复用，**方法调用，循环跳转，异常跳转**
* 如何使所有线程都在最近的安全点停顿？
  * 抢占式（没有虚拟机采用）：首先终端所有线程，若还有线程不在安全点，就恢复线程，让线程跑到安全点
  * 主动式中断：设置终端标志，各线程执行到 安全点时主动的轮询这个标志，若为真，就自己主动挂起。

**安全区域**：

安全点保证了程序在不太长的时间就会遇到 GC 的安全点。**但是若程序本来就是阻塞态，那么就无法响应JVM终端请求**，针对这种的需要安全区域解决。

* 安全区域指的是：一段代码中，引用关系不发生变化，这个区域任何位置就是安全的。
* 在线程执行到 Safe Region 代码时，会标识进入了安全区，那么JVM在进行GC时，就不会管 进入安全区的线程。
* 在线程离开安全区时，会检查系统是否已完成 可达性分析，若完成则继续执行，没有完成等到完成后再继续执行。

#### 6、强引用-弱引用-软引用-虚引用

**强引用**：可触及的； Object obj = new Object()；只要强引用存在，GC就不会回收他。

**软引用**：**软可触及（内存不足就回收）SoftReference**系统将要发生OOM之前，会把这种对象放入回收范围内进行二次回收，这次回收之后还是内存不足，就抛出OOM。实现内存敏感的缓存，高速缓存就有用到软引用。

**弱引用**：**弱可触及 WeakReference**，弱引用关联的对象只能存活在下一次GC之前，**只要GC 就被回收**

**虚引用**：虚可触及，虚引用不会对其生存产生影响。目的对象在被回收时收到 系统的通知。取不到对象

总结：弱引用，软引用都适合保存缓存数据。

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：使用过 WeakHashMap吗？**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答:  1、弱引用的HashMap</span> 

## 十八、垃圾回收器

#### 1、GC分类，性能指标

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：java8的新特性**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答: 1：语法层面：lambda，switch，自动装箱，enum<>; 2：API： Stream， 新的日期，集合框架； 3：底层： JVM优化，GC的变化</span> 

**分类：**

1. 线程数：串行，并行
2. 工作模式：并发式垃圾回收，独占式垃圾回收
3. 碎片处理：压缩式，非压缩式
4. 工作区间：年轻代，老年代

**性能指标**

* **吞吐量**（运行用户代码占总运行的时间比例）
* 垃圾收集开销
* **暂停时间**
* 收集效率
* **内存占用**：堆区所占用内存的大小
* 快速: 一个对象从诞生到被回收的时间。

抓住，**吞吐量**，**暂停时间**

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：JVM调优主要在那两方面？**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答: 吞吐量，暂停时间。</span>

**吞吐量**：运行用户代码的时间 / （运行用户代码的时间 + 垃圾收集的时间） 

![image-20210318135529319](.\picture\image-20210318135529319.png)

对比：图1 暂停时间高（延迟高），吞吐量好。图2 暂停时间低（低延迟），垃圾回收频率高。

* 选择吞吐量优先，就会降低GC的频率，那么需要更多的暂停时间进行GC
* 以低延迟为目标，会频繁的进行GC，年轻代的内存缩减，程序的吞吐量下降。 

<span style='color:pink'>在最大吞吐量的优先的情况下。降低停顿时间</span>

<span style='color:pink'>G1 垃圾回收：在可控的暂停时间，增加吞吐量</span>

#### 2、不同垃圾回收器

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：Java中常见的垃圾回收器？**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答: JVM有不同厂商是实现，在不同的JVM不同的环境下有不同的GC</span>

![image-20210318140551957](.\picture\image-20210318140551957.png)

**经典**

* 串行： Serial, Serial Old

* 并行： Parnew, Parallel Scavenge, Parallel Old

* 并发：CMS, G1 

  ![image-20210318141720216](.\picture\image-20210318141720216.png)

  ![image-20210318141800356](.\picture\image-20210318141800356.png)

  ![image-20210318141833893](.\picture\image-20210318141833893.png)

  ![image-20210318142519072](.\picture\image-20210318142519072.png)

  JDK 8 : 新生代：UseParallelGC，老年代使用 Parallel Old

  JDK 11 ： 使用 G1 GC

#### 3、Serial GC(串行回收)

* 最基本的，最久的GC，用于年轻代 
* 单线程，会产生 STW，暂停其他线程直至回收结束。
* 作为 Hotspot 中 client 模式下默认的新生代GC
* 使用复制算法，串行回收和 STW 机制

**Serial Old 与 Serial 搭配， 用于老年代：**

* 在 Client模式下 默认的老年代 垃圾回收器
* 标记-压缩 
* 与 **Parallel Scavenge 配合使用，作为老年代CMS的备胎（后备方案）**

![image-20210318143347489](.\picture\image-20210318143347489.png)

<span style='color:pink'>优点：简单高效</span>

<span style='color:pink'>只在单核的使用，基本不再使用了</span>

#### 4、ParNew（并行）

* 采用并行回收，用于新生代。
* 复制算法，STW
* 在Server端， 是默认的新生代。 **老年代可以使用 CMS/ Serial Old**

![image-20210318143714931](.\picture\image-20210318143714931.png)

对于新生代：回收次数频繁，并行效率高

对于老年代：回收次数少，串行节省资源，（CPU 并行需要切换线程，串行可以省去切换线程的资源）

#### 5、Parallel Scavenge回收器（吞吐优先）

* 新生代，使用复制算法，STW，并行回收
* 为什么要使用 Parallel ？
  * 和 ParNew 不同， Parallel目的是 吞吐量 
  * 自适应调节策略也和 ParNew不一样
* 高吞吐：尽快的完成任务，不需要太多的交互，后台运行的（订单批量处理，工资支付）
* Parallel Old JDK6 时提供了 Parallel Old 方法
  * 采用标记-压缩
  * 使用 STW ，并行回收

![image-20210318144659715](.\picture\image-20210318144659715.png)

#### 6、CMS（低延迟）

* (Concurent-Mark-Sweep) 并发垃圾回收
* 尽可能的减低停顿时间，适合交互多的程序。
* 使用 标记-清除， STW
* CMS 最为老年代收集器，只能和 ParNew 和 Serial 合作。与 Parallel 不兼容。

![image-20210318145356739](.\picture\image-20210318145356739.png)

* **初始标记：**STW ----- **仅仅**标记出 GC-roots 直接关联的对象。追求快
* **并发标记：**从直接关联对象开始遍历整个对象图，整个过程花费时间较长，但不需要停顿用户线程。
* **重新标记**：STW ---- 修正并发期间，用户程序继续运作而导致的 标记变动。耗时也短。
* **并发清除**：释放已死亡的对象，释放空间。 （清除易造成碎片问题，所以后续会采用 Serial Old 作为备选。）
* <span style="color:pink">总结：因为 STW 花费时间都比较短，最耗时的步骤并发标记，并发清除，并发执行不需要STW，所以CMS追求低延迟</span>

<img src=".\picture\image-20210318150317549.png" alt="image-20210318150317549" style="zoom: 80%;" />

**缺点：**

* 因为使用的标记--清除算法，容易产生内存碎片。用户线程可用空间不足，会提前触发Full GC

* CMS收集器对CPU资源敏感
* CMS无法处理浮动垃圾。**浮动垃圾**：并发清理时用户程序还在执行，就会有新的垃圾产生，但是无法被标记，那么就无法及时回收。

<span style='color:red;background:背景颜色;font-size:18px;font-family:字体;'>**问题：那为什么不使用 Mark--compact？**</span>

<span style='color:yellow;background:背景颜色;font-size:18px;font-family:字体;'>答: 因为标记压缩涉及到地址移动问题，而因为并发，所以用户线程也在运行，使用标记压缩 </span>

#### 7、G1（可控的暂停，提高吞吐量）

##### **1.特点**

* **并行与并发：**
  1. 并行：可以多个G1线程同时工作，使用多个CPU减少STW的时间。
  2. 并发：G1 与用户应用程序并发执行。
* **分代收集**：将内存分成不同的代，不要求连续，因为分为了不同的Region
* **空间整合**： 整体上使用 标记- 压缩（整理），两个region之间时复制算法。可以避免碎片化。
* **可预测的停顿**： 建立可预测的停顿时间模型，在M毫秒的时间之内，垃圾回收的时间不超过N毫秒  
* G1 有计划的避免整个Java堆的全区域的垃圾回收，G1跟踪每个Region的大小（回收所得的空间大小，回收所需要的时间），在后台维护一个优先列表，目的在于回收打击最大量的区间。 Garbage First。 

<img src=".\picture\image-20210318205713666.png" alt="image-20210318205713666" style="zoom:67%;" />

**与CMS对比：**

* G1 占用的空间多
* 小内存CMS优，大内存的6-8 G1优

<img src=".\picture\image-20210318211051260.png" alt="image-20210318211051260" style="zoom:67%;" />

**使用场景**

* 面向服务端应用，针对大内存，多处理器。
* 应用需要低延迟，具有大堆的应用程序

##### **2.Region**

* G1 收集器，将堆划分为2048个独立的Region，整体被控制在1 - 32 MB且为2 的次幂

* 所有的Region 大小相同，且不会改变

* -XX:G!HeapRegionSize设定 

* region 分别是 Eden，S0,S1，老年代，Humongous（超过1.5 region情况下就放在H ）

  设置H的原因，堆中的大对象会直接分配到老年代，若是个短期的大对象，就容易产生负面影响。若一个H放不下，就寻找连续的H。将H区当作老年代。

  <img src=".\picture\image-20210318213920543.png" alt="image-20210318213920543" style="zoom:67%;" />

##### 3.过程

* YoungGC：Eden 用尽，触发YoungGC，并行的独占式。STW，启动多线程回收年轻代。
* 老年代并发标记过程：当堆空间使用了45以上，开始并发标记。
* 混合回收：标记结束，立马**混合回收，**在混合回收过程中，将老年代存活的对象移动到空闲区，而空闲区会成为新的老年代。（只选择价值高的region）
* 可能会 Full GC

<img src=".\picture\image-20210318214724833.png" alt="image-20210318214724833" style="zoom: 67%;" />

**Remember Set**：

* 一个对象可能被不同区域所引用
* 一个Region不是孤立的，判断对象是否存活需要扫描整个堆
* 回收新生代不得不扫描老年代。 

**解决办法:**

* 无论是G1 还是其他的分代收集器，JVM都是使用 Remember Set 解决的。
* 每个Region 都有自己的记忆集。
* 每次 Reference 类型数据进行写操作时，会产生 Writer Barrier （写屏障）的中断
* 检查写入的引用对象是否和该Reference对象在不同的 Region 
* 若不同，相关的引用信息记录在引用对象的所在Region表。
* 在进行 内存回收时，GC根节点的范围中加入 Remember Set 的，保证了不全局扫描，也不会遗漏。

**详细过程（1-Young GC）**

1. 不断地创建对象放入Eden 区，若Eden 区满了，收集Eden和Survival区
2.  YGC，STW，G1创建垃圾回收集（需要被回收的内存分段集合-----Eden 与 Survival 的内存分段）

**2. 并发标记过程（old）**

1. 初始标记阶段，只标记 GC Root 直接相连的对象。
2. 跟区域扫描，G1 扫描 S区可直达老年区的对象，标记被引用的对象。（因为要改动S区，所以必须在YGC 之前完成）
3. 并发标记：实施回收（发现这个区域全是垃圾），并发标记阶段时会计算这个Region的活性。
4. 再次标记：因为并发标记，所以需要再次确认，使用初始快照的算法（SATB）
5. 独占清理 : STW
6. 并发清理

**3. 混合回收**

<img src=".\picture\image-20210318231855047.png" alt="image-20210318231855047" style="zoom: 67%;" />

<img src=".\picture\image-20210318232008289.png" alt="image-20210318232008289" style="zoom: 67%;" />![image-20210318232241511](.\picture\image-20210318232241511.png)

![image-20210318232241511](.\picture\image-20210318232241511.png)

#### 8、GC回收器总结

![image-20210318232332686](.\picture\image-20210318232332686.png)

<img src=".\picture\image-20210318232442284.png" alt="image-20210318232442284" style="zoom:67%;" />

![image-20210318232705570](.\picture\image-20210318232705570.png)